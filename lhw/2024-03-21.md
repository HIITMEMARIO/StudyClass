# 2024-03-21
1. 면접준비 및 면접 질문 자가 피드백

# 기술 면접 질문 자가 피드백

# div와 span과 p의 차이

- div - 박스단위로 가로 영역 전체 차지, display: block
- span - 줄 단위로 컨텐츠 크기만큼 영역 차지, display:inline
- p - 단락 단위로 영역 차지, display:block

# inline, block, inline-block 차이

- inline - 한줄에 나란히 배치 (span, a, em)
- block - 줄 바꿈을 실행 (header, footer, p, li, table, div, h1)
- inline-block - block 처럼 width, height가 지정 가능하지만, 한줄에 나란히 배치한다. 즉, 내부적으로는 block, 외부적으로는 inline이 적용된다. (button, input, select)

# JWT Token과 Session, 쿠키의 차이

## 쿠키

- 클라이언트에 저장될 목적으로 생성한 작은 정보를 담은 파일(서버에서 사용자 브라우저로 전송한다.)
- 브라우저는 서버에서 받은 쿠키를 저장해두었다가, 동일한 서버로 재요청할 때 쿠키를 함께 전송한다.
- 사용자가 로그인을 하면, 서버는 ID, PW 정보를 쿠키에 담아 브라우저로 다시 보낸다. 이후 브라우저에서는 요청할 때마다 로그인 정보가 담긴 쿠키를 함께 서버로 보낸다. 브라우저에서 매번 요청할 때마다 서버 입장에서는 로그인 정보가 담긴 쿠키를 받게 되는 것이다.

### 쿠키의 장점

- 기존 로그인 정보를 사용하기 때문에 인증을 위한 추가적인 데이터 저장이 필요 없다.(쿠키는 서버가 아닌 클라이언트 웹 브라우저에 한다.)

### 쿠키의 단점

- 사용자의 주요 정보를 매번 요청에 담기 때문에 보안상 문제가 있다.
- 클라이언트에서 쿠키 정보를 쉽게 변경, 삭제할 수 있고, 가로채기 당할 수도 있다.
- 쿠키 사이즈가 커질수록 네트워크 부하가 심해진다.

## 세션

- 서버에서 일정시간 동안 클라이언트 상태를 유지하기 위해 사용하는 기술
- 서버에서 클라이언트별 유일한 세션 ID를 부여하고, 세션 정보를 서버에 저장한다.
    - 세션 ID : 사용자의 주요 정보가 아닌, 단지 사용자를 식별할 수 있는 값을 생성한다. → 보안 강화
- 서버에서 생성한 세션 ID는 클라이언트의 쿠키 값(세션 쿠키)으로 저장되고, 클라이언트에서 요청을 보낼 때 이 세션 쿠키를 함께 보낸다. 서버에서는 클라이언트별 세션 쿠키 값이 저장되어 있으니, 요청으로 온 세션 쿠키 값을 보고 어떤 클라이언트인지 식별할 수 있다.

### 세션의 장점

- 사용자의 로그인 정보를 주고 받지 않기 때문에 상대적으로 안전하다.
- 사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원DB를 찾지 않아도 된다.

### 세션의 단점

- 사용자를 식별할 수 있는 값인 세션 ID를 생성하고, 서버에 저장해야하는 작업이 생긴다.
- 서버 세션 저장소를 사용하므로 요청이 많아지면 서버 부하가 심해진다.

## JWT Token

- JWT : 인증에 필요한 정보들을 암호화시킨 토큰
- JWT 토큰(Access Token)을 HTTP 헤더에 담아 서버가 클라이언트를 식별한다.

### JWT 구조

- Header
    - 토큰 타입, 해쉬 알고리즘(HS256 or RSA 등)으로 구성되어 있다.
        
        ```json
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        ```
        
- Payload
    - claim이 포함되는 영역으로, 토큰에 담을 정보를 갖고 있다.
        - claim : key-value 형식으로 이루어진 한 쌍의 정보로, 엔티티(주로 사용자)에 대한 속성을 설명한다.
    - 클라이언트 고유 ID 값이나 유효 기간 등이 포함되는 영역이다.
        
        ```json
        {
          "sub": "1234567890",
          "username": "user1",
          "admin": true
        }
        ```
        
- Signature
    - 인코딩된 Header와 Payload를 더한 뒤, secret key로 해싱해서 생성한다. 이 때, 해싱 방법은 Header에서 지정한 해쉬 알고리즘 방법으로 한다.
    - Header와 Payload는 단순히 인코딩된 값이어서 누구든 복호화가 가능하나, Signature는 서버 측에서 관리하는 secret key가 있어야 복호화가 가능하다.
    - Signature 부분으로 토큰의 위변조 여부를 확인할 수 있다.
        
        ```json
        HMACSHA256(
          base64UrlEncode(header) + "." +
          base64UrlEncode(payload),
          secret)
        ```
        

### JWT 작동 방식

1. 클라이언트가 ID, PW 로그인 요청을 보낸다.
2. 회원 DB에서 사용자를 확인한다.
3. 로그인 성공 시, 서버는 로그인 정보를 Payload에 담고, Secret Key를 사용해서 Access Token(JWT)을 발급한다.
4. 서버가 JWT를 Client에 전달한다. 이 때 전달방법은 개발자가 정한다.
    
    ex) 응답 Header에 `Authorization: BEARER <JWT>` 형태로 전달
    
5. 클라이언트는 전달받은 토큰(JWT)을 저장한다.(쿠키, local storage 등)
6. 클라이언트가 서버에 요청할 때마다 토큰(JWT)을 요청 Header의 `Authorization` 에 포함시켜 함께 전달한다.
7. 서버는 클라이언트가 전달한 토큰의 Signature를 secret Key로 복호화한 후, 위변조 여부 및 유효기간을 검증한다.
8. 검증에 성공하면, JWT에서 사용자 정보를 확인하고 요청에 응답한다.

### JWT 장점

- 동시 접속자가 많을 때 서버 부하를 낮춘다.
- 클라이언트, 서버가 다른 도메인을 사용할 때 사용 가능하다.
    - ex) 카카오 OAuth2 로그인 시 JWT 토큰 사용
- 인증 정보를 서버에 별도로 저장할 필요가 없다. → 서버의 Stateless 특성이 유지된다.

### JWT 단점

- 구현 복잡도가 증가한다.
- JWT에 담는 내용이 커질수록 네트워크 비용이 증가한다.
- 이미 생성된 JWT를 일부만 만료시킬 방법이 없다. (토큰의 유효기간을 너무 길게 잡으면 안된다.)
- Secret Key 유출 시 JWT 조작이 가능하다.
- Payload 자체는 암호화되지 않기 때문에 사용자의 중요한 정보는 담을 수 없다.

### 세션과 JWT토큰 차이

1. 저장 위치:
    - JWT 토큰: JWT(토큰 기반 인증) 토큰은 클라이언트 측에 저장됩니다. 주로 클라이언트의 웹 브라우저나 모바일 앱 내의 로컬 저장소(localStorage 또는 sessionStorage)에 저장됩니다.
    - 세션: 세션은 서버 측에 저장됩니다. 서버는 클라이언트에게 세션 식별자를 부여하고, 해당 식별자를 사용하여 세션 데이터를 관리합니다.
2. 서버 상태:
    - JWT 토큰: JWT 토큰은 상태를 저장하지 않습니다. 토큰에 필요한 모든 정보가 포함되어 있으므로, 서버는 클라이언트의 요청을 처리할 때 추가적인 상태를 유지할 필요가 없습니다.
    - 세션: 세션은 서버 측에 상태를 저장합니다. 클라이언트의 상태 및 세션 데이터에 대한 관리는 서버가 담당하며, 세션 데이터베이스나 메모리에 저장됩니다.
3. 확장성:
    - JWT 토큰: JWT 토큰은 클라이언트 측에 저장되므로, 여러 서버나 도메인 간에 쉽게 공유될 수 있습니다. 따라서 분산 환경에서 확장성이 높습니다.
    - 세션: 세션은 서버 측에 저장되고 서버가 관리하므로, 여러 서버 간에 세션 데이터를 공유하기 위한 추가적인 작업이 필요합니다. 이로 인해 분산 환경에서의 확장성이 낮을 수 있습니다.
4. 유효 기간:
    - JWT 토큰: JWT 토큰은 발급될 때 유효 기간이 설정될 수 있으며, 해당 기간 동안 유효합니다. 만료 기간이 지나면 클라이언트는 새로운 토큰을 요청해야 합니다.
    - 세션: 세션은 클라이언트의 브라우저가 닫힐 때까지 유지됩니다. 서버는 클라이언트의 세션을 삭제하거나 만료시키는 정책을 설정할 수 있습니다.

### 세션과 토큰의 취약점

1. 세션의 취약점:
    - 세션 하이재킹: 세션 식별자를 탈취하여 다른 사용자로 위장하여 세션을 탈취하거나 조작할 수 있습니다.
    - 세션 고정화 공격: 공격자가 세션 식별자를 고정하여 사용자의 세션을 장기간 유지하고 이를 악용하여 권한 상승이나 다른 공격을 수행할 수 있습니다.
    - 세션 시간 초과: 세션이 서버에 지속적으로 유지되는 경우, 세션 하이재킹 등의 공격에 취약해질 수 있습니다.
2. JWT 토큰의 취약점:
    - 정보 노출: JWT 토큰은 클라이언트 측에 저장되므로, 클라이언트 측에서 탈취될 경우 토큰에 포함된 정보가 노출될 수 있습니다.
    - 토큰 변조: 공격자가 JWT 토큰을 조작하여 페이로드를 변경하거나 권한을 부여받을 수 있습니다.
    - 재생 공격: 만료 기간이 지나지 않은 유효한 JWT 토큰을 재사용하여 권한을 획득할 수 있습니다.

### 취약점 해결

1. 세션 취약점 해결:
    - 세션 하이재킹 방지를 위해 SSL을 사용하여 통신을 암호화합니다. 이렇게 하면 공격자가 세션 식별자를 가로채더라도 해당 세션을 위조하기 어렵습니다.
    - 세션 식별자를 랜덤하고 예측 불가능한 값으로 생성하여 세션 고정화 공격을 방지합니다.
    - 세션 타임아웃을 짧게 설정하여 세션을 지속하는 시간을 최소화하여 세션 하이재킹 공격에 대비합니다.
2. 토큰 취약점 해결:
    - JWT 토큰을 사용할 때는 민감한 정보(예: 비밀번호)를 저장하지 않도록 주의해야 합니다. 필요한 경우 JWT 토큰 내에 저장된 정보를 최소화합니다.
    - 토큰에 대한 서명(Signature)을 사용하여 토큰의 무결성을 보장합니다. 이를 통해 토큰 변조 공격을 방지할 수 있습니다.
    - 토큰을 안전한 저장소에 저장하고 전송할 때는 HTTPS를 사용하여 통신을 암호화합니다.
    - 토큰의 만료 기간을 적절히 설정하여 재생 공격을 방지합니다.

# XSS공격

XSS 는 크로스 사이트 스크립팅으로 해커가 게시판 제목이나 이미지에 스크립트를 삽입하여 웹 브라우저에서 실행되도록 하는 공격이다.

XSS 를 막기 위한 방법으로는 HTTP 통신외에 쿠키에 접근 불가능하도록 하는것이다.

HTTPOnly 속성의 쿠키는 자바스크립트로 접근이 불가능하다.

# Record, Pick, Omit, Partial

- Record - 전달받은 Type을 Key로 하는 객체 타입을 생성한다. Type은 인덱스 시그니쳐가 된다.
- Pick - 전달받은 Type에서 keys를 뽑아서 타입을 생성한다.
- Omit - 전달받은 Type에서 keys를 제외한 타입을 생성한다.
- Partial - 전달받은 Type의 모든 하위집합 타입을 생성한다.

# Button의 기본 display 속성

inline-block

# bcrypt

bcrypt는 비밀번호 해싱 함수입니다. 단방향 해싱 함수로, 해시된 비밀번호는 복호화 할 수 없습니다. 

bcrypt는 솔트와 슬로우해싱을 사용합니다. 솔트는 해시된 비밀번호에 고유값을 추가하는것을 말합니다. 슬로우 해싱은 bcrypt가 많은 연산을 요구하기 때문에 공격자가 무차별 대입하는것을 어렵게 합니다. 

# useFowardRef

useRef는 HTML DOM 요소에 직접 접근할 수 있는 리액트 훅 입니다.

useFowardRef는 함수형 컴포넌트에서 사용합니다. 부모 컴포넌트에서 자식컴포넌트의 ref를 접근하고 싶을때, 함수형 컴포넌트는 인스턴스가 없어서 ref에 접근할 수 없을때 사용합니다.